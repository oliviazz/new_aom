{"version":3,"file":"LiveQueryProvider.js","sources":["../../src/LiveQueryProvider/LiveQueryProvider.tsx"],"sourcesContent":["import type {\n  ClientConfig,\n  ContentSourceMap,\n  ContentSourceMapDocuments,\n  QueryParams,\n  SanityClient,\n  SanityDocument,\n} from '@sanity/client'\nimport { applySourceDocuments } from '@sanity/client/csm'\nimport { useDocumentsInUse, useRevalidate } from '@sanity/preview-kit-compat'\nimport { vercelStegaSplit } from '@vercel/stega'\nimport { LRUCache } from 'lru-cache'\nimport { applyPatch } from 'mendoza'\nimport {\n  memo,\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react'\n\nimport { defineStoreContext as Context } from '../context'\nimport type {\n  DefineListenerContext,\n  ListenerGetSnapshot,\n  ListenerSubscribe,\n  LiveQueryProviderProps,\n} from '../types'\n\nconst DEFAULT_TAG = 'sanity.preview-kit'\n\n// Documents share the same cache even if there are nested providers, with a Least Recently Used (LRU) cache\nconst documentsCache = new LRUCache<\n  ReturnType<typeof getTurboCacheKey>,\n  SanityDocument\n>({\n  // Max 500 documents in memory, no big deal if a document is evicted it just means the eventual consistency might take longer\n  max: 500,\n})\n\n/**\n * @internal\n */\nconst LiveStoreProvider = memo(function LiveStoreProvider(\n  props: LiveQueryProviderProps,\n) {\n  const { children, refreshInterval = 10000, token } = props\n\n  if (!props.client) {\n    throw new Error(\n      'Missing a `client` prop with a configured Sanity client instance',\n    )\n  }\n\n  // Ensure these values are stable even if userland isn't memoizing properly\n  const [client] = useState(() => {\n    const { requestTagPrefix, resultSourceMap } = props.client.config()\n    return props.client.withConfig({\n      requestTagPrefix: requestTagPrefix || DEFAULT_TAG,\n      resultSourceMap:\n        resultSourceMap === 'withKeyArraySelector'\n          ? 'withKeyArraySelector'\n          : true,\n      // Set the recommended defaults, this is a convenience to make it easier to share a client config from a server component to the client component\n      ...(token && {\n        token,\n        useCdn: false,\n        perspective: 'previewDrafts',\n        ignoreBrowserTokenWarning: true,\n      }),\n    })\n  })\n  const [logger] = useState(() => props.logger)\n\n  useEffect(() => {\n    if (logger) {\n      logger.log(\n        `[@sanity/preview-kit]: With the current configuration you can expect that: Updates that can be traced using Content Source Maps will be applied in real-time. Other updates will be applied every ${refreshInterval}ms.`,\n      )\n    }\n  }, [logger, refreshInterval])\n\n  const [subscriptions, setSubscriptions] = useState<QueryCacheKey[]>([])\n  const [snapshots] = useState<QuerySnapshotsCache>(() => new Map())\n  const hooks = useHooks(setSubscriptions)\n  const [context] = useState<DefineListenerContext>(() => {\n    return function defineListener<QueryResult>(\n      initialSnapshot: QueryResult,\n      query: string,\n      params: QueryParams,\n    ) {\n      const key = getQueryCacheKey(query, params)\n\n      // Warm up the cache by setting the initial snapshot, showing stale-while-revalidate\n      if (!snapshots.has(key)) {\n        snapshots.set(key, {\n          result: initialSnapshot,\n          resultSourceMap: {} as ContentSourceMap,\n        })\n      }\n\n      const subscribe: ListenerSubscribe = (onStoreChange) => {\n        const unsubscribe = hooks.subscribe(key, query, params, onStoreChange)\n\n        return () => unsubscribe()\n      }\n      const getSnapshot: ListenerGetSnapshot<QueryResult> = () =>\n        snapshots.get(key)?.result as unknown as QueryResult\n\n      return { subscribe, getSnapshot }\n    } satisfies DefineListenerContext\n  })\n  const [turboIds, setTurboIds] = useState<string[]>([])\n  const [docsInUse] = useState(\n    () => new Map<string, ContentSourceMapDocuments[number]>(),\n  )\n  const turboIdsFromSourceMap = useCallback(\n    (contentSourceMap: ContentSourceMap) => {\n      // This handler only adds ids, on each query fetch. But that's ok since <Turbo /> purges ids that are unused\n      const nextTurboIds = new Set<string>()\n      docsInUse.clear()\n      if (contentSourceMap.documents?.length) {\n        for (const document of contentSourceMap.documents) {\n          nextTurboIds.add(document._id)\n          docsInUse.set(document._id, document)\n        }\n      }\n      startTransition(() =>\n        setTurboIds((prevTurboIds) => {\n          const mergedTurboIds = Array.from(\n            new Set([...prevTurboIds, ...nextTurboIds]),\n          )\n          if (\n            JSON.stringify(mergedTurboIds.sort()) ===\n            JSON.stringify(prevTurboIds.sort())\n          ) {\n            return prevTurboIds\n          }\n          return mergedTurboIds\n        }),\n      )\n    },\n    [docsInUse],\n  )\n\n  return (\n    <Context.Provider value={context}>\n      {children}\n      <Turbo\n        cache={hooks.cache}\n        client={client}\n        setTurboIds={setTurboIds}\n        snapshots={snapshots}\n        turboIds={turboIds}\n        docsInUse={docsInUse}\n      />\n      {subscriptions.map((key) => {\n        if (!hooks.cache.has(key)) return null\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const { query, params, listeners } = hooks.cache.get(key)!\n        return (\n          <QuerySubscription\n            key={key}\n            client={client}\n            listeners={listeners}\n            params={params}\n            query={query}\n            refreshInterval={refreshInterval}\n            snapshots={snapshots}\n            turboIdsFromSourceMap={turboIdsFromSourceMap}\n          />\n        )\n      })}\n    </Context.Provider>\n  )\n})\nLiveStoreProvider.displayName = 'LiveStoreProvider'\nexport default LiveStoreProvider\n\ninterface QuerySubscriptionProps\n  extends Required<Pick<LiveQueryProviderProps, 'client' | 'refreshInterval'>> {\n  query: string\n  params: QueryParams\n  listeners: Set<() => void>\n  turboIdsFromSourceMap: (contentSourceMap: ContentSourceMap) => void\n  snapshots: QuerySnapshotsCache\n}\nconst QuerySubscription = memo(function QuerySubscription(\n  props: QuerySubscriptionProps,\n) {\n  const {\n    client,\n    refreshInterval,\n    query,\n    params,\n    listeners,\n    snapshots,\n    turboIdsFromSourceMap,\n  } = props\n  const { projectId, dataset } = useMemo(() => {\n    const { projectId, dataset } = client.config()\n    return { projectId, dataset } as Required<\n      Pick<ClientConfig, 'projectId' | 'dataset'>\n    >\n  }, [client])\n\n  // Make sure any async errors bubble up to the nearest error boundary\n  const [error, setError] = useState<unknown>(null)\n  if (error) throw error\n\n  const [revalidate, startRefresh] = useRevalidate({ refreshInterval })\n  const shouldRefetch = revalidate === 'refresh' || revalidate === 'inflight'\n  useEffect(() => {\n    if (!shouldRefetch) {\n      return\n    }\n\n    let fulfilled = false\n    const controller = new AbortController()\n    // eslint-disable-next-line no-inner-declarations\n    async function effect() {\n      const { signal } = controller\n      const { result, resultSourceMap } = await (client as SanityClient).fetch(\n        query,\n        params,\n        {\n          signal,\n          filterResponse: false,\n        },\n      )\n\n      if (!signal.aborted) {\n        snapshots.set(getQueryCacheKey(query, params), {\n          result: turboChargeResultIfSourceMap(\n            projectId,\n            dataset,\n            result,\n            resultSourceMap,\n          ),\n          resultSourceMap: resultSourceMap ?? ({} as ContentSourceMap),\n        })\n\n        if (resultSourceMap) {\n          turboIdsFromSourceMap(resultSourceMap)\n        }\n\n        // Notify listeners that snapshots are updated\n        for (const listener of listeners.values()) {\n          listener()\n        }\n        fulfilled = true\n      }\n    }\n    const onFinally = startRefresh()\n    effect()\n      .catch((error) => {\n        if (error.name !== 'AbortError') {\n          setError(error)\n        }\n      })\n      .finally(onFinally)\n    return () => {\n      if (!fulfilled) {\n        controller.abort()\n      }\n    }\n  }, [\n    client,\n    dataset,\n    listeners,\n    params,\n    projectId,\n    query,\n    shouldRefetch,\n    snapshots,\n    startRefresh,\n    turboIdsFromSourceMap,\n  ])\n\n  return null\n})\nQuerySubscription.displayName = 'QuerySubscription'\n\ntype QuerySnapshotsCache = Map<\n  QueryCacheKey,\n  { result: unknown; resultSourceMap: ContentSourceMap }\n>\n\nfunction getTurboCacheKey(\n  projectId: string,\n  dataset: string,\n  _id: string,\n): `${string}-${string}-${string}` {\n  return `${projectId}-${dataset}-${_id}`\n}\n\ntype LiveStoreQueryCacheMap = Map<\n  QueryCacheKey,\n  { query: string; params: QueryParams; listeners: Set<() => void> }\n>\n\n/**\n * Keeps track of store subscribers per cache key, in a way that's designed for useSyncExternalStore.\n * The main difference from a typical subscription state with useEffect is that `adding` and `cleanup`\n * is wholly managed by the `subscribe` function in `useSyncExternalStore`, instead of lifecycles in useEffect.\n * And since the `onStoreChange` callback, provided to `subscribe`, notifies React when to re-render,\n * there is no need to use `setState` to trigger a re-render. That's why the Map is persisted in `useState` but the state setter isn't used.\n */\nfunction useHooks(\n  setSubscriptions: React.Dispatch<React.SetStateAction<QueryCacheKey[]>>,\n): {\n  cache: LiveStoreQueryCacheMap\n  subscribe: (\n    key: QueryCacheKey,\n    query: string,\n    params: QueryParams,\n    listener: () => void,\n  ) => () => void\n} {\n  const [cache] = useState<LiveStoreQueryCacheMap>(() => new Map())\n  const subscribe = useCallback(\n    (\n      key: QueryCacheKey,\n      query: string,\n      params: QueryParams,\n      listener: () => void,\n    ) => {\n      if (!cache.has(key)) {\n        cache.set(key, { query, params, listeners: new Set<() => void>() })\n        startTransition(() =>\n          setSubscriptions((prevSubscriptions) => {\n            if (prevSubscriptions.includes(key)) {\n              return prevSubscriptions\n            }\n            return [...prevSubscriptions, key]\n          }),\n        )\n      }\n      const hook = cache.get(key)\n      if (!hook || !hook.listeners) {\n        throw new TypeError('Inconsistent cache for key: ' + key)\n      }\n      const { listeners } = hook\n      listeners.add(listener)\n      return () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          cache.delete(key)\n          startTransition(() =>\n            setSubscriptions((prevSubscriptions) => {\n              if (prevSubscriptions.includes(key)) {\n                return prevSubscriptions.filter((sub) => sub !== key)\n              }\n              return prevSubscriptions\n            }),\n          )\n        }\n      }\n    },\n    [cache, setSubscriptions],\n  )\n  return useMemo(() => ({ cache, subscribe }), [cache, subscribe])\n}\n\ninterface TurboProps extends Pick<LiveQueryProviderProps, 'client'> {\n  turboIds: string[]\n  docsInUse: Map<string, ContentSourceMapDocuments[number]>\n  setTurboIds: React.Dispatch<React.SetStateAction<string[]>>\n  cache: LiveStoreQueryCacheMap\n  snapshots: QuerySnapshotsCache\n}\n/**\n * A turbo-charged mutation observer that uses Content Source Maps to apply mendoza patches on your queries\n */\nconst Turbo = memo(function Turbo(props: TurboProps) {\n  const { client, snapshots, cache, turboIds, setTurboIds, docsInUse } = props\n  const { projectId, dataset } = useMemo(() => {\n    const { projectId, dataset } = client.config()\n    return { projectId, dataset } as Required<\n      Pick<ClientConfig, 'projectId' | 'dataset'>\n    >\n  }, [client])\n\n  // Keep track of document ids that the active `useLiveQuery` hooks care about\n  useEffect(() => {\n    const nextTurboIds = new Set<string>()\n    docsInUse.clear()\n    for (const { query, params } of cache.values()) {\n      const key = getQueryCacheKey(query, params)\n      const snapshot = snapshots.get(key)\n      if (snapshot && snapshot.resultSourceMap?.documents?.length) {\n        for (const document of snapshot.resultSourceMap.documents) {\n          nextTurboIds.add(document._id)\n          docsInUse.set(document._id, document)\n        }\n      }\n    }\n    const nextTurboIdsSnapshot = [...nextTurboIds].sort()\n    if (JSON.stringify(turboIds) !== JSON.stringify(nextTurboIdsSnapshot)) {\n      startTransition(() => setTurboIds(nextTurboIdsSnapshot))\n    }\n  }, [cache, setTurboIds, snapshots, turboIds, docsInUse])\n  // Sync with Presentation Tool if present\n  useDocumentsInUse(docsInUse, projectId, dataset)\n\n  // Figure out which documents are misssing from the cache\n  const [batch, setBatch] = useState<string[][]>([])\n  useEffect(() => {\n    const batchSet = new Set(batch.flat())\n    const nextBatch = new Set<string>()\n    for (const turboId of turboIds) {\n      if (\n        !batchSet.has(turboId) &&\n        !documentsCache.has(getTurboCacheKey(projectId, dataset, turboId))\n      ) {\n        nextBatch.add(turboId)\n      }\n    }\n    const nextBatchSlice = [...nextBatch].slice(0, 100)\n    if (nextBatchSlice.length === 0) return\n    startTransition(() =>\n      setBatch((prevBatch) => [...prevBatch.slice(-100), nextBatchSlice]),\n    )\n  }, [batch, dataset, projectId, turboIds])\n\n  const [lastMutatedDocumentId, setLastMutatedDocumentId] = useState<string>()\n  // Use the same listen instance and patch documents as they come in\n  useEffect(() => {\n    const subscription = (client as SanityClient)\n      .listen(\n        `*`,\n        {},\n        {\n          events: ['mutation'],\n          effectFormat: 'mendoza',\n          includePreviousRevision: false,\n          includeResult: false,\n          tag: 'turbo',\n        },\n      )\n      .subscribe((update) => {\n        if (update.type !== 'mutation' || !update.effects?.apply?.length) return\n        // Schedule a reach state update with the ID of the document that were mutated\n        // This react handler will apply the document to related source map snapshots\n        const key = getTurboCacheKey(projectId, dataset, update.documentId)\n        const cachedDocument = documentsCache.peek(key)\n        if (cachedDocument as SanityDocument) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const patchDoc = { ...cachedDocument } as any\n          delete patchDoc._rev\n          const patchedDocument = applyPatch(patchDoc, update.effects.apply)\n          documentsCache.set(key, patchedDocument)\n        }\n\n        startTransition(() => setLastMutatedDocumentId(update.documentId))\n      })\n    return () => subscription.unsubscribe()\n  }, [client, dataset, projectId])\n\n  // If the last mutated document is in the list over turboIds then lets apply the source map\n  useEffect(() => {\n    if (!lastMutatedDocumentId || !turboIds.includes(lastMutatedDocumentId))\n      return\n\n    const updatedKeys: QueryCacheKey[] = []\n    for (const [key, snapshot] of snapshots.entries()) {\n      if (snapshot.resultSourceMap?.documents?.length) {\n        snapshot.result = turboChargeResultIfSourceMap(\n          projectId,\n          dataset,\n          snapshot.result,\n          snapshot.resultSourceMap,\n        )\n        updatedKeys.push(key)\n      }\n    }\n    for (const updatedKey of updatedKeys) {\n      const listeners = cache.get(updatedKey)?.listeners\n      if (listeners) {\n        for (const listener of listeners) {\n          listener()\n        }\n      }\n    }\n    startTransition(() => setLastMutatedDocumentId(undefined))\n  }, [cache, dataset, lastMutatedDocumentId, projectId, snapshots, turboIds])\n\n  return (\n    <>\n      {batch.map((ids) => (\n        <GetDocuments\n          key={JSON.stringify(ids)}\n          client={client}\n          projectId={projectId}\n          dataset={dataset}\n          ids={ids}\n        />\n      ))}\n    </>\n  )\n})\nTurbo.displayName = 'Turbo'\n\ninterface GetDocumentsProps extends Pick<LiveQueryProviderProps, 'client'> {\n  projectId: string\n  dataset: string\n  ids: string[]\n}\nconst GetDocuments = memo(function GetDocuments(props: GetDocumentsProps) {\n  const { client, projectId, dataset, ids } = props\n\n  useEffect(() => {\n    const missingIds = ids.filter(\n      (id) => !documentsCache.has(getTurboCacheKey(projectId, dataset, id)),\n    )\n    if (missingIds.length === 0) return\n    client.getDocuments(missingIds).then((documents) => {\n      for (const doc of documents) {\n        if (doc && doc?._id) {\n          documentsCache.set(getTurboCacheKey(projectId, dataset, doc._id), doc)\n        }\n      }\n      // eslint-disable-next-line no-console\n    }, console.error)\n  }, [client, dataset, ids, projectId])\n\n  return null\n})\nGetDocuments.displayName = 'GetDocuments'\n\nlet warnedAboutCrossDatasetReference = false\nfunction turboChargeResultIfSourceMap(\n  projectId: string,\n  dataset: string,\n  result: unknown,\n  resultSourceMap?: ContentSourceMap,\n) {\n  if (!resultSourceMap) return result\n\n  return applySourceDocuments(\n    result,\n    resultSourceMap,\n    (sourceDocument) => {\n      if (sourceDocument._projectId) {\n        // eslint-disable-next-line no-warning-comments\n        // @TODO Handle cross dataset references\n        if (!warnedAboutCrossDatasetReference) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            'Cross dataset references are not supported yet, ignoring source document',\n            sourceDocument,\n          )\n          warnedAboutCrossDatasetReference = true\n        }\n        return undefined\n      }\n      return documentsCache.get(\n        getTurboCacheKey(projectId, dataset, sourceDocument._id),\n      )\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (changedValue: any, { previousValue }) => {\n      if (\n        typeof changedValue === 'string' &&\n        typeof previousValue === 'string'\n      ) {\n        // Preserve stega encoded strings, if they exist\n        const { encoded } = vercelStegaSplit(previousValue)\n        const { cleaned } = vercelStegaSplit(changedValue)\n        return `${encoded}${cleaned}`\n      }\n      return changedValue\n    },\n    'previewDrafts',\n  )\n}\n\n/** @internal */\ntype QueryCacheKey = `${string}-${string}`\n/** @internal */\nfunction getQueryCacheKey(query: string, params: QueryParams): QueryCacheKey {\n  return `${query}-${JSON.stringify(params)}`\n}\n"],"names":["documentsCache","LRUCache","max","LiveStoreProvider","memo","props","children","refreshInterval","token","client","Error","useState","requestTagPrefix","resultSourceMap","config","withConfig","useCdn","perspective","ignoreBrowserTokenWarning","logger","useEffect","log","subscriptions","setSubscriptions","snapshots","Map","hooks","cache","subscribe","useCallback","key","query","params","listener","has","set","listeners","Set","startTransition","prevSubscriptions","includes","hook","get","TypeError","add","delete","size","filter","sub","useMemo","useHooks","context","initialSnapshot","getQueryCacheKey","result","onStoreChange","unsubscribe","getSnapshot","_a","turboIds","setTurboIds","docsInUse","turboIdsFromSourceMap","contentSourceMap","nextTurboIds","clear","documents","length","document","_id","prevTurboIds","mergedTurboIds","Array","from","JSON","stringify","sort","Context","Provider","value","jsx","Turbo","map","QuerySubscription","displayName","projectId","dataset","error","setError","revalidate","startRefresh","useRevalidate","shouldRefetch","fulfilled","controller","AbortController","onFinally","async","signal","fetch","filterResponse","aborted","turboChargeResultIfSourceMap","values","effect","catch","error2","name","finally","abort","getTurboCacheKey","_b","snapshot","nextTurboIdsSnapshot","useDocumentsInUse","batch","setBatch","batchSet","flat","nextBatch","turboId","nextBatchSlice","slice","prevBatch","lastMutatedDocumentId","setLastMutatedDocumentId","subscription","listen","events","effectFormat","includePreviousRevision","includeResult","tag","update","type","effects","apply","documentId","cachedDocument","peek","patchDoc","_rev","patchedDocument","applyPatch","_c","updatedKeys","entries","push","updatedKey","Fragment","ids","GetDocuments","missingIds","id","getDocuments","then","doc","console","warnedAboutCrossDatasetReference","applySourceDocuments","sourceDocument","_projectId","warn","changedValue","previousValue","encoded","vercelStegaSplit","cleaned"],"mappings":"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"}