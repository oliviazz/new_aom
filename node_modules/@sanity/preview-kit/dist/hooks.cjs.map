{"version":3,"file":"hooks.cjs","sources":["../src/hooks.ts"],"sourcesContent":["import type { QueryParams as ClientQueryParams } from '@sanity/client'\nimport { useQueryParams } from '@sanity/preview-kit-compat'\nimport { useCallback, useContext, useMemo, useState } from 'react'\nimport isFastEqual from 'react-fast-compare'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector.js'\n\nimport { defineStoreContext } from './context'\nimport {\n  ListenerGetSnapshot,\n  ListenerSubscribe,\n  QueryEnabled,\n  QueryLoading,\n} from './types'\n\n/**\n * By default 'react-fast-compare' is used to check if the query result has changed.\n * It's reasonably fast, but you can make it even faster by providing your own function as you know which\n * part of the query result is visible to the user, and which parts can skip rendering.\n * @public\n */\nexport type isEqualFn<QueryResult> = (a: QueryResult, b: QueryResult) => boolean\n\n/** @public */\nexport interface LiveQueryHookOptions<QueryResult> {\n  isEqual?: isEqualFn<QueryResult>\n}\n\n/** @public */\nexport function useLiveQuery<\n  QueryResult,\n  QueryParams extends ClientQueryParams = ClientQueryParams,\n>(\n  initialData: QueryResult,\n  query: string,\n  queryParams?: QueryParams,\n  options?: LiveQueryHookOptions<QueryResult>,\n): [QueryResult, QueryLoading, QueryEnabled] {\n  const { isEqual = isFastEqual } = options || {}\n\n  const defineStore = useContext(defineStoreContext)\n  const params = useQueryParams(queryParams)\n  const noStore = useMemo(\n    () => ({\n      subscribe: (() => () => {}) satisfies ListenerSubscribe,\n      getSnapshot: () => initialData,\n    }),\n    [initialData],\n  )\n  const store = useMemo<\n    | {\n        subscribe: ListenerSubscribe\n        getSnapshot: ListenerGetSnapshot<QueryResult>\n      }\n    | undefined\n  >(\n    () =>\n      defineStore?.<QueryResult>(initialData, query, params) || {\n        subscribe: (() => () => {}) satisfies ListenerSubscribe,\n        getSnapshot: () => initialData,\n      },\n    [defineStore, initialData, params, query],\n  )\n  // initialSnapshot might change before hydration is done, so deep cloning it on the first hook call\n  // helps ensure that we don't get a mismatch between the server and client snapshots\n  const [serverSnapshot] = useState(() => {\n    if (initialData === undefined) {\n      throw new Error(\n        `initialSnapshot can't be undefined, if you don't want an initial value use null instead`,\n      )\n    }\n    try {\n      return JSON.parse(JSON.stringify(initialData))\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"Failed to deep clone initialSnapshot, this is likely an error and an indication that the snapshot isn't JSON serializable\",\n        { initialSnapshot: initialData, error },\n      )\n      return initialData\n    }\n  })\n  const getServerSnapshot = useCallback(() => serverSnapshot, [serverSnapshot])\n  const selector = useCallback((snapshot: QueryResult) => snapshot, [])\n\n  const snapshot = useSyncExternalStoreWithSelector(\n    store?.subscribe || noStore.subscribe,\n    store?.getSnapshot || noStore.getSnapshot,\n    getServerSnapshot,\n    selector,\n    isEqual,\n  )\n  const enabled = defineStore !== null\n  const loading = enabled && serverSnapshot === snapshot\n\n  return [snapshot, loading, enabled]\n}\n\n/**\n * The `useLiveQuery` hook is designed to work in environments where the parent `LiveQueryProvider` may be lazy loaded.\n * Thus if it can't \"know\" if it's \"live\" or not, or of it will be later. When everything is setup correctly this is fine.\n * This hook on the other hand does know. If it returns `false` then sibling `useLiveQuery` hooks are not \"live\".\n * If it returns `true` then sibling `useLiveQuery` hooks are \"live\" as there is a parent `LiveQueryProvider` in the tree that is loaded and active.\n * @public\n * @deprecated use `useLiveQuery` instead: `const [,,enabled] = useLiveQuery(initialData, query, params)`\n */\nexport function useIsEnabled(): boolean {\n  return useContext(defineStoreContext) !== null\n}\n"],"names":["exports","useIsEnabled","useContext","defineStoreContext","useLiveQuery","initialData","query","queryParams","options","isEqual","isFastEqual","defineStore","params","useQueryParams","noStore","useMemo","subscribe","getSnapshot","store","serverSnapshot","useState","Error","JSON","parse","stringify","error","console","warn","initialSnapshot","getServerSnapshot","useCallback","selector","snapshot","useSyncExternalStoreWithSelector","enabled"],"mappings":"uUA2GAA,QAAAC,aAFO,WACE,OAAmC,OAAnCC,EAAAA,WAAWC,qBACpB,EAAAH,QAAAI,aA/EO,SAILC,EACAC,EACAC,EACAC,GAEM,MAAAC,QAAEA,EAAUC,EAAAA,SAAgBF,GAAW,CAAC,EAExCG,EAAcT,EAAAA,WAAWC,EAAkBA,oBAC3CS,EAASC,EAAAA,eAAeN,GACxBO,EAAUC,EAAAA,SACd,KAAO,CACLC,UAAY,IAAM,OAClBC,YAAa,IAAMZ,KAErB,CAACA,IAEGa,EAAQH,EAAAA,SAOZ,KACE,MAAAJ,OAAA,EAAAA,EAA2BN,EAAaC,EAAOM,KAAW,CACxDI,UAAY,IAAM,OAClBC,YAAa,IAAMZ,IAEvB,CAACM,EAAaN,EAAaO,EAAQN,KAI9Ba,GAAkBC,EAAAA,UAAS,KAChC,QAAoB,IAAhBf,EACF,MAAM,IAAIgB,MACR,2FAGA,IACF,OAAOC,KAAKC,MAAMD,KAAKE,UAAUnB,UAC1BoB,GAEC,OAAAC,QAAAC,KACN,4HACA,CAAEC,gBAAiBvB,EAAaoB,UAE3BpB,CACT,KAEIwB,EAAoBC,eAAY,IAAMX,GAAgB,CAACA,IACvDY,EAAWD,eAAaE,GAA0BA,GAAU,IAE5DA,EAAWC,EAAAA,kCACf,MAAAf,OAAA,EAAAA,EAAOF,YAAaF,EAAQE,WAC5B,MAAAE,OAAA,EAAAA,EAAOD,cAAeH,EAAQG,YAC9BY,EACAE,EACAtB,GAEIyB,EAA0B,OAAhBvB,EAGhB,MAAO,CAACqB,EAFQE,GAAWf,IAAmBa,EAEnBE,EAC7B"}