{"version":3,"file":"webhook.js","sources":["../src/webhook/index.ts"],"sourcesContent":["import type {SanityDocument} from '@sanity/types'\nimport {isValidSignature, SIGNATURE_HEADER_NAME} from '@sanity/webhook'\nimport type {NextApiRequest} from 'next'\nimport type {NextRequest} from 'next/server'\nimport type {PageConfig} from 'next/types'\n\n/**\n * Configurates the API function with the right runtime and body parsing to handle Sanity Webhook events.\n * @public\n * @deprecated using `parseBody` with `NextApiRequest` is deprecated and will be removed in the next major version. Use `parseBody` with `NextRequest` instead from a Route Handler in App Router.\n */\nexport const config: PageConfig = {\n  api: {\n    /**\n     * Next.js will by default parse the body, which can lead to invalid signatures.\n     */\n    bodyParser: false,\n  },\n  runtime: 'nodejs',\n}\n\n/** @public */\nexport type ParsedBody<T> = {\n  /**\n   * If a secret is given then it returns a boolean. If no secret is provided then no validation is done on the signature, and it'll return `null`\n   */\n  isValidSignature: boolean | null\n  body: T | null\n}\n\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n * @deprecated using `parseBody` with `NextApiRequest` is deprecated and will be removed in the next major version. Use `parseBody` with `NextRequest` instead from a Route Handler in App Router.\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n// eslint-disable-next-line require-await\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest | NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  return 'text' in req\n    ? parseAppBody(req, secret, waitForContentLakeEventualConsistency)\n    : parsePageBody(req, secret, waitForContentLakeEventualConsistency)\n}\n\n/** @deprecated */\nasync function parsePageBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  let signature = req.headers[SIGNATURE_HEADER_NAME]\n  if (Array.isArray(signature)) {\n    signature = signature[0]\n  }\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  if (req.readableEnded) {\n    throw new Error(\n      `Request already ended and the POST body can't be read. Have you setup \\`export {config} from 'next-sanity/webhook' in your webhook API handler?\\``,\n    )\n  }\n\n  const body = await readBody(req)\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n\nasync function parseAppBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  const signature = req.headers.get(SIGNATURE_HEADER_NAME)!\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  const body = await req.text()\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 3000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n\nasync function readBody(readable: NextApiRequest): Promise<string> {\n  const chunks = []\n  for await (const chunk of readable) {\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk)\n  }\n  return Buffer.concat(chunks).toString('utf8')\n}\n"],"names":["isValidSignature","SIGNATURE_HEADER_NAME","config","api","bodyParser","runtime","async","parseBody","req","secret","waitForContentLakeEventualConsistency","signature","headers","get","console","error","body","text","validSignature","trim","Promise","resolve","setTimeout","JSON","parse","parseAppBody","Array","isArray","readableEnded","Error","readable","chunks","chunk","push","Buffer","from","concat","toString","readBody","parsePageBody"],"mappings":"2BAWOA,2BAAAC,MAAA,kBAAA,MAAMC,EAAqB,CAChCC,IAAK,CAIHC,YAAY,GAEdC,QAAS,UAkCXC,eAAsBC,EACpBC,EACAC,EACAC,GAAiD,GAE1C,MAAA,SAAUF,EAuCnBF,eACEE,EACAC,EACAC,GAAiD,GAEjD,MAAMC,EAAYH,EAAII,QAAQC,IAAIZ,GAClC,IAAKU,EACH,OAAAG,QAAQC,MAAM,4BACP,CAACC,KAAM,KAAMhB,iBAAkB,MAGxC,MAAMgB,QAAaR,EAAIS,OACjBC,EAAiBT,QAAeT,EAAiBgB,EAAML,EAAWF,EAAOU,QAAU,KAEzF,OAAuB,IAAnBD,GAA4BR,SACxB,IAAIU,SAASC,GAAYC,WAAWD,EAAS,OAG9C,CACLL,KAAMA,EAAKG,OAASI,KAAKC,MAAMR,GAAQ,KACvChB,iBAAkBkB,EAEtB,CA5DMO,CAAajB,EAAKC,EAAQC,GAKhCJ,eACEE,EACAC,EACAC,GAAiD,GAE7C,IAAAC,EAAYH,EAAII,QAAQX,GACxB,GAAAyB,MAAMC,QAAQhB,KAChBA,EAAYA,EAAU,KAEnBA,EACH,OAAAG,QAAQC,MAAM,4BACP,CAACC,KAAM,KAAMhB,iBAAkB,MAGxC,GAAIQ,EAAIoB,cACN,MAAM,IAAIC,MACR,mJAIJ,MAAMb,QAqCRV,eAAwBwB,GACtB,MAAMC,EAAS,GACf,UAAA,MAAiBC,KAASF,EACjBC,EAAAE,KAAsB,iBAAVD,EAAqBE,OAAOC,KAAKH,GAASA,GAE/D,OAAOE,OAAOE,OAAOL,GAAQM,SAAS,OACxC,CA3CqBC,CAAS9B,GACtBU,EAAiBT,QAAeT,EAAiBgB,EAAML,EAAWF,EAAOU,QAAU,KAEzF,OAAuB,IAAnBD,GAA4BR,SACxB,IAAIU,SAASC,GAAYC,WAAWD,EAAS,OAG9C,CACLL,KAAMA,EAAKG,OAASI,KAAKC,MAAMR,GAAQ,KACvChB,iBAAkBkB,EAEtB,CAnCMqB,CAAc/B,EAAKC,EAAQC,EACjC"}