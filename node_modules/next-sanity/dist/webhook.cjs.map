{"version":3,"file":"webhook.cjs","sources":["../src/webhook/index.ts"],"sourcesContent":["import type {SanityDocument} from '@sanity/types'\nimport {isValidSignature, SIGNATURE_HEADER_NAME} from '@sanity/webhook'\nimport type {NextApiRequest} from 'next'\nimport type {NextRequest} from 'next/server'\nimport type {PageConfig} from 'next/types'\n\n/**\n * Configurates the API function with the right runtime and body parsing to handle Sanity Webhook events.\n * @public\n * @deprecated using `parseBody` with `NextApiRequest` is deprecated and will be removed in the next major version. Use `parseBody` with `NextRequest` instead from a Route Handler in App Router.\n */\nexport const config: PageConfig = {\n  api: {\n    /**\n     * Next.js will by default parse the body, which can lead to invalid signatures.\n     */\n    bodyParser: false,\n  },\n  runtime: 'nodejs',\n}\n\n/** @public */\nexport type ParsedBody<T> = {\n  /**\n   * If a secret is given then it returns a boolean. If no secret is provided then no validation is done on the signature, and it'll return `null`\n   */\n  isValidSignature: boolean | null\n  body: T | null\n}\n\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n * @deprecated using `parseBody` with `NextApiRequest` is deprecated and will be removed in the next major version. Use `parseBody` with `NextRequest` instead from a Route Handler in App Router.\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n// eslint-disable-next-line require-await\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest | NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  return 'text' in req\n    ? parseAppBody(req, secret, waitForContentLakeEventualConsistency)\n    : parsePageBody(req, secret, waitForContentLakeEventualConsistency)\n}\n\n/** @deprecated */\nasync function parsePageBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  let signature = req.headers[SIGNATURE_HEADER_NAME]\n  if (Array.isArray(signature)) {\n    signature = signature[0]\n  }\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  if (req.readableEnded) {\n    throw new Error(\n      `Request already ended and the POST body can't be read. Have you setup \\`export {config} from 'next-sanity/webhook' in your webhook API handler?\\``,\n    )\n  }\n\n  const body = await readBody(req)\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n\nasync function parseAppBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  const signature = req.headers.get(SIGNATURE_HEADER_NAME)!\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  const body = await req.text()\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 3000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n\nasync function readBody(readable: NextApiRequest): Promise<string> {\n  const chunks = []\n  for await (const chunk of readable) {\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk)\n  }\n  return Buffer.concat(chunks).toString('utf8')\n}\n"],"names":["Object","defineProperty","exports","value","webhook","require","config","api","bodyParser","runtime","parseBody","async","req","secret","waitForContentLakeEventualConsistency","signature","headers","get","SIGNATURE_HEADER_NAME","console","error","body","isValidSignature","text","validSignature","trim","Promise","resolve","setTimeout","JSON","parse","parseAppBody","Array","isArray","readableEnded","Error","readable","chunks","chunk","push","Buffer","from","concat","toString","readBody","parsePageBody"],"mappings":"aAWOA,OAAAC,eAAAC,QAAA,aAAA,CAAAC,OAAA,IAAA,IAAAC,EAAAC,QAAA,mBAmHPH,QAAAI,OAnHkC,CAChCC,IAAK,CAIHC,YAAY,GAEdC,QAAS,UA4GXP,QAAAQ,UA1EAC,eACEC,EACAC,EACAC,GAAiD,GAE1C,MAAA,SAAUF,EAuCnBD,eACEC,EACAC,EACAC,GAAiD,GAEjD,MAAMC,EAAYH,EAAII,QAAQC,IAAIC,EAAqBA,uBACvD,IAAKH,EACH,OAAAI,QAAQC,MAAM,4BACP,CAACC,KAAM,KAAMC,iBAAkB,MAGxC,MAAMD,QAAaT,EAAIW,OACjBC,EAAiBX,QAAeS,EAAAA,iBAAiBD,EAAMN,EAAWF,EAAOY,QAAU,KAEzF,OAAuB,IAAnBD,GAA4BV,SACxB,IAAIY,SAASC,GAAYC,WAAWD,EAAS,OAG9C,CACLN,KAAMA,EAAKI,OAASI,KAAKC,MAAMT,GAAQ,KACvCC,iBAAkBE,EAEtB,CA5DMO,CAAanB,EAAKC,EAAQC,GAKhCH,eACEC,EACAC,EACAC,GAAiD,GAE7C,IAAAC,EAAYH,EAAII,QAAQE,EAAqBA,uBAC7C,GAAAc,MAAMC,QAAQlB,KAChBA,EAAYA,EAAU,KAEnBA,EACH,OAAAI,QAAQC,MAAM,4BACP,CAACC,KAAM,KAAMC,iBAAkB,MAGxC,GAAIV,EAAIsB,cACN,MAAM,IAAIC,MACR,mJAIJ,MAAMd,QAqCRV,eAAwByB,GACtB,MAAMC,EAAS,GACf,UAAA,MAAiBC,KAASF,EACjBC,EAAAE,KAAsB,iBAAVD,EAAqBE,OAAOC,KAAKH,GAASA,GAE/D,OAAOE,OAAOE,OAAOL,GAAQM,SAAS,OACxC,CA3CqBC,CAAShC,GACtBY,EAAiBX,QAAeS,EAAAA,iBAAiBD,EAAMN,EAAWF,EAAOY,QAAU,KAEzF,OAAuB,IAAnBD,GAA4BV,SACxB,IAAIY,SAASC,GAAYC,WAAWD,EAAS,OAG9C,CACLN,KAAMA,EAAKI,OAASI,KAAKC,MAAMT,GAAQ,KACvCC,iBAAkBE,EAEtB,CAnCMqB,CAAcjC,EAAKC,EAAQC,EACjC"}